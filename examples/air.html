

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Attend Infer Repeat &mdash; Pyro Tutorials  documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="Pyro Tutorials  documentation" href="index.html"/>
        <link rel="prev" title="Modeling Polyphonic Music with a Deep Markov Model" href="dmm.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Pyro Tutorials
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="svi_part_i.html">SVI Part I: An Introduction to Stochastic Variational Inference in Pyro</a></li>
<li class="toctree-l1"><a class="reference internal" href="svi_part_i.html#The-ELBO">The ELBO</a></li>
<li class="toctree-l1"><a class="reference internal" href="svi_part_i.html#Optimizers">Optimizers</a></li>
<li class="toctree-l1"><a class="reference internal" href="svi_part_i.html#A-simple-example">A simple example</a></li>
<li class="toctree-l1"><a class="reference internal" href="svi_part_ii.html">SVI Part II: Conditional Independence, Subsampling, and Amortization</a></li>
<li class="toctree-l1"><a class="reference internal" href="svi_part_iii.html">SVI Part III: ELBO Gradient Estimators</a></li>
<li class="toctree-l1"><a class="reference internal" href="vae.html">Variational Autoencoders</a></li>
<li class="toctree-l1"><a class="reference internal" href="vae.html#A-VAE-in-Pyro">A VAE in Pyro</a></li>
<li class="toctree-l1"><a class="reference internal" href="vae.html#Inference">Inference</a></li>
<li class="toctree-l1"><a class="reference internal" href="vae.html#Sample-results-[COMPLETE]">Sample results [COMPLETE]</a></li>
<li class="toctree-l1"><a class="reference internal" href="bayesian_regression.html">Bayesian Regression</a></li>
<li class="toctree-l1"><a class="reference internal" href="dmm.html">Modeling Polyphonic Music with a Deep Markov Model</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Attend Infer Repeat</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#Introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#The-Model">The Model</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Generating-a-single-object">Generating a single object</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Generating-an-entire-image">Generating an entire image</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#Aside:-Vectorized-mini-batches">Aside: Vectorized mini-batches</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Specifying-the-likelihood">Specifying the likelihood</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#The-Guide">The Guide</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Another-perspective">Another perspective</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#Inference">Inference</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Data-dependent-baselines">Data dependent baselines</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Putting-it-altogether">Putting it altogether</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#Improvements">Improvements</a></li>
<li class="toctree-l2"><a class="reference internal" href="#Results">Results</a></li>
<li class="toctree-l2"><a class="reference internal" href="#References">References</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Pyro Tutorials</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Attend Infer Repeat</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/air.ipynb.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS for nbsphinx extension */

/* remove conflicting styling from Sphinx themes */
div.nbinput,
div.nbinput div.prompt,
div.nbinput div.input_area,
div.nbinput div[class*=highlight],
div.nbinput div[class*=highlight] pre,
div.nboutput,
div.nbinput div.prompt,
div.nbinput div.output_area,
div.nboutput div[class*=highlight],
div.nboutput div[class*=highlight] pre {
    background: none;
    border: none;
    padding: 0 0;
    margin: 0;
    box-shadow: none;
}

/* avoid gaps between output lines */
div.nboutput div[class*=highlight] pre {
    line-height: normal;
}

/* input/output containers */
div.nbinput,
div.nboutput {
    display: -webkit-flex;
    display: flex;
    align-items: flex-start;
    margin: 0;
    width: 100%;
}
@media (max-width: 540px) {
    div.nbinput,
    div.nboutput {
        flex-direction: column;
    }
}

/* input container */
div.nbinput {
    padding-top: 5px;
}

/* last container */
div.nblast {
    padding-bottom: 5px;
}

/* input prompt */
div.nbinput div.prompt pre {
    color: #303F9F;
}

/* output prompt */
div.nboutput div.prompt pre {
    color: #D84315;
}

/* all prompts */
div.nbinput div.prompt,
div.nboutput div.prompt {
    min-width: 8ex;
    padding-top: 0.4em;
    padding-right: 0.4em;
    text-align: right;
    flex: 0;
}
@media (max-width: 540px) {
    div.nbinput div.prompt,
    div.nboutput div.prompt {
        text-align: left;
        padding: 0.4em;
    }
    div.nboutput div.prompt.empty {
        padding: 0;
    }
}

/* disable scrollbars on prompts */
div.nbinput div.prompt pre,
div.nboutput div.prompt pre {
    overflow: hidden;
}

/* input/output area */
div.nbinput div.input_area,
div.nboutput div.output_area {
    padding: 0.4em;
    -webkit-flex: 1;
    flex: 1;
    overflow: auto;
}
@media (max-width: 540px) {
    div.nbinput div.input_area,
    div.nboutput div.output_area {
        width: 100%;
    }
}

/* input area */
div.nbinput div.input_area {
    border: 1px solid #cfcfcf;
    border-radius: 2px;
    background: #f7f7f7;
}

/* override MathJax center alignment in output cells */
div.nboutput div[class*=MathJax] {
    text-align: left !important;
}

/* override sphinx.ext.pngmath center alignment in output cells */
div.nboutput div.math p {
    text-align: left;
}

/* standard error */
div.nboutput div.output_area.stderr {
    background: #fdd;
}

/* ANSI colors */
.ansi-black-fg { color: #3E424D; }
.ansi-black-bg { background-color: #3E424D; }
.ansi-black-intense-fg { color: #282C36; }
.ansi-black-intense-bg { background-color: #282C36; }
.ansi-red-fg { color: #E75C58; }
.ansi-red-bg { background-color: #E75C58; }
.ansi-red-intense-fg { color: #B22B31; }
.ansi-red-intense-bg { background-color: #B22B31; }
.ansi-green-fg { color: #00A250; }
.ansi-green-bg { background-color: #00A250; }
.ansi-green-intense-fg { color: #007427; }
.ansi-green-intense-bg { background-color: #007427; }
.ansi-yellow-fg { color: #DDB62B; }
.ansi-yellow-bg { background-color: #DDB62B; }
.ansi-yellow-intense-fg { color: #B27D12; }
.ansi-yellow-intense-bg { background-color: #B27D12; }
.ansi-blue-fg { color: #208FFB; }
.ansi-blue-bg { background-color: #208FFB; }
.ansi-blue-intense-fg { color: #0065CA; }
.ansi-blue-intense-bg { background-color: #0065CA; }
.ansi-magenta-fg { color: #D160C4; }
.ansi-magenta-bg { background-color: #D160C4; }
.ansi-magenta-intense-fg { color: #A03196; }
.ansi-magenta-intense-bg { background-color: #A03196; }
.ansi-cyan-fg { color: #60C6C8; }
.ansi-cyan-bg { background-color: #60C6C8; }
.ansi-cyan-intense-fg { color: #258F8F; }
.ansi-cyan-intense-bg { background-color: #258F8F; }
.ansi-white-fg { color: #C5C1B4; }
.ansi-white-bg { background-color: #C5C1B4; }
.ansi-white-intense-fg { color: #A1A6B2; }
.ansi-white-intense-bg { background-color: #A1A6B2; }

.ansi-bold { font-weight: bold; }

/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast,
.nboutput.nblast {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast + .nbinput {
    margin-top: -19px;
}

/* nice headers on first paragraph of info/warning boxes */
.admonition .first {
    margin: -12px;
    padding: 6px 12px;
    margin-bottom: 12px;
    color: #fff;
    line-height: 1;
    display: block;
}
.admonition.warning .first {
    background: #f0b37e;
}
.admonition.note .first {
    background: #6ab0de;
}
.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}
</style>
<div class="section" id="Attend-Infer-Repeat">
<h1>Attend Infer Repeat<a class="headerlink" href="#Attend-Infer-Repeat" title="Permalink to this headline">¶</a></h1>
<p>In this tutorial we will implement the “Attend Infer Repeat” (AIR) model
[1] and apply it to the multi-mnist dataset.</p>
<p>A <a class="reference external" href="https://github.com/uber/pyro/blob/dev/examples/air/air.py">standalone
implementation</a>
is also available.</p>
<p style="border: 1px solid red; padding: 1em"><p>Current status: Pyro has everything needed to describe this model and
inference strategy, but we have yet to collect any experimental results.
We will add results to this tutorial once we have them.</p>
</p><div class="nbinput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="o">%</span><span class="k">pylab</span> inline
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">namedtuple</span>
<span class="kn">import</span> <span class="nn">pyro</span>
<span class="kn">import</span> <span class="nn">pyro.optim</span> <span class="k">as</span> <span class="nn">optim</span>
<span class="kn">from</span> <span class="nn">pyro.infer</span> <span class="k">import</span> <span class="n">SVI</span>
<span class="kn">import</span> <span class="nn">pyro.distributions</span> <span class="k">as</span> <span class="nn">dist</span>
<span class="kn">from</span> <span class="nn">pyro.util</span> <span class="k">import</span> <span class="n">ng_zeros</span><span class="p">,</span> <span class="n">ng_ones</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">from</span> <span class="nn">torch.autograd</span> <span class="k">import</span> <span class="n">Variable</span>
<span class="kn">import</span> <span class="nn">torch.nn</span> <span class="k">as</span> <span class="nn">nn</span>
<span class="kn">from</span> <span class="nn">torch.nn.functional</span> <span class="k">import</span> <span class="n">relu</span><span class="p">,</span> <span class="n">sigmoid</span><span class="p">,</span> <span class="n">softplus</span><span class="p">,</span> <span class="n">grid_sample</span><span class="p">,</span> <span class="n">affine_grid</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Populating the interactive namespace from numpy and matplotlib
</pre></div></div>
</div>
<div class="section" id="Introduction">
<h2>Introduction<a class="headerlink" href="#Introduction" title="Permalink to this headline">¶</a></h2>
<p>AIR is a generative model of scenes. In this tutorial we will use it to
model images from dataset this is simialar to the multi-mnist dataset in
[1]. Here are some data points from this data set:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="n">fn</span> <span class="o">=</span> <span class="s1">&#39;../../examples/air/data/multi_mnist_train_uint8.npz&#39;</span>
<span class="n">mnist</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fn</span><span class="p">)[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="o">/</span> <span class="mf">255.</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">show_images</span><span class="p">(</span><span class="n">imgs</span><span class="p">):</span>
    <span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">img</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">imgs</span><span class="p">):</span>
        <span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">imgs</span><span class="p">),</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">imshow</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;binary&#39;</span><span class="p">)</span>
<span class="n">show_images</span><span class="p">(</span><span class="n">mnist</span><span class="p">[</span><span class="mi">9</span><span class="p">:</span><span class="mi">14</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
<span class="ansi-red-fg">---------------------------------------------------------------------------</span>
<span class="ansi-red-fg">IOError</span>                                   Traceback (most recent call last)
<span class="ansi-green-fg">&lt;ipython-input-2-c5fa54938bca&gt;</span> in <span class="ansi-cyan-fg">&lt;module&gt;</span><span class="ansi-blue-fg">()</span>
<span class="ansi-green-intense-fg ansi-bold">      1</span> fn <span class="ansi-blue-fg">=</span> <span class="ansi-blue-fg">&#39;../../examples/air/data/multi_mnist_train_uint8.npz&#39;</span>
<span class="ansi-green-fg">----&gt; 2</span><span class="ansi-red-fg"> </span>mnist <span class="ansi-blue-fg">=</span> Variable<span class="ansi-blue-fg">(</span>torch<span class="ansi-blue-fg">.</span>from_numpy<span class="ansi-blue-fg">(</span>np<span class="ansi-blue-fg">.</span>load<span class="ansi-blue-fg">(</span>fn<span class="ansi-blue-fg">)</span><span class="ansi-blue-fg">[</span><span class="ansi-blue-fg">&#39;x&#39;</span><span class="ansi-blue-fg">]</span><span class="ansi-blue-fg">.</span>astype<span class="ansi-blue-fg">(</span>np<span class="ansi-blue-fg">.</span>float32<span class="ansi-blue-fg">)</span> <span class="ansi-blue-fg">/</span> <span class="ansi-cyan-fg">255.</span><span class="ansi-blue-fg">)</span><span class="ansi-blue-fg">)</span>
<span class="ansi-green-intense-fg ansi-bold">      3</span> <span class="ansi-green-fg">def</span> show_images<span class="ansi-blue-fg">(</span>imgs<span class="ansi-blue-fg">)</span><span class="ansi-blue-fg">:</span>
<span class="ansi-green-intense-fg ansi-bold">      4</span>     figure<span class="ansi-blue-fg">(</span>figsize<span class="ansi-blue-fg">=</span><span class="ansi-blue-fg">(</span><span class="ansi-cyan-fg">12</span><span class="ansi-blue-fg">,</span><span class="ansi-cyan-fg">4</span><span class="ansi-blue-fg">)</span><span class="ansi-blue-fg">)</span>
<span class="ansi-green-intense-fg ansi-bold">      5</span>     <span class="ansi-green-fg">for</span> i<span class="ansi-blue-fg">,</span> img <span class="ansi-green-fg">in</span> enumerate<span class="ansi-blue-fg">(</span>imgs<span class="ansi-blue-fg">)</span><span class="ansi-blue-fg">:</span>

<span class="ansi-green-fg">/usr/local/lib/python2.7/site-packages/numpy/lib/npyio.pyc</span> in <span class="ansi-cyan-fg">load</span><span class="ansi-blue-fg">(file, mmap_mode, allow_pickle, fix_imports, encoding)</span>
<span class="ansi-green-intense-fg ansi-bold">    368</span>     own_fid <span class="ansi-blue-fg">=</span> False
<span class="ansi-green-intense-fg ansi-bold">    369</span>     <span class="ansi-green-fg">if</span> isinstance<span class="ansi-blue-fg">(</span>file<span class="ansi-blue-fg">,</span> basestring<span class="ansi-blue-fg">)</span><span class="ansi-blue-fg">:</span>
<span class="ansi-green-fg">--&gt; 370</span><span class="ansi-red-fg">         </span>fid <span class="ansi-blue-fg">=</span> open<span class="ansi-blue-fg">(</span>file<span class="ansi-blue-fg">,</span> <span class="ansi-blue-fg">&#34;rb&#34;</span><span class="ansi-blue-fg">)</span>
<span class="ansi-green-intense-fg ansi-bold">    371</span>         own_fid <span class="ansi-blue-fg">=</span> True
<span class="ansi-green-intense-fg ansi-bold">    372</span>     <span class="ansi-green-fg">elif</span> is_pathlib_path<span class="ansi-blue-fg">(</span>file<span class="ansi-blue-fg">)</span><span class="ansi-blue-fg">:</span>

<span class="ansi-red-fg">IOError</span>: [Errno 2] No such file or directory: &#39;../../examples/air/data/multi_mnist_train_uint8.npz&#39;
</pre></div></div>
</div>
<p>To get an idea where we’re heading, we first give a brief overview of
the model and the approach we’ll take to inference. We’ll follow the
naming conventions used in [1] as closely as possible.</p>
<p>AIR decomposes the process of generating an image into discrete steps,
each of which generates only part of the image. More specifically, at
each step the model will generate a small image (<code class="docutils literal"><span class="pre">y_att</span></code>) by passing a
latent “code” variable (<code class="docutils literal"><span class="pre">z_what</span></code>) through a neural network. We’ll
refer to these small images as “objects”. In the case of AIR applied to
the multi-mnist dataset we expect each of these objects to represent a
single digit. The model also includes uncertainty about the location and
size of each object. We’ll describe an object’s location and size as its
“pose” (<code class="docutils literal"><span class="pre">z_where</span></code>). To produce the final image, each object will first
be located within a larger image (<code class="docutils literal"><span class="pre">y</span></code>) using the pose infomation
<code class="docutils literal"><span class="pre">z_where</span></code>. Finally, the <code class="docutils literal"><span class="pre">y</span></code>s from all time steps will be combined
additively to produce the final image <code class="docutils literal"><span class="pre">x</span></code>.</p>
<p>Here’s a picture (reproduced from [1]) that shows two steps of this
process:</p>
<p>Inference in performed in this model using <a class="reference external" href="http://pyro.ai/examples/svi_part_i.html">amortized variational
inference</a>. The parameters
of the neural network are also optimized during inference. Performing
inference in such rich models is always difficult, but the presence of
discrete choices (the number of steps in this case) makes inference in
this model particularly tricky. For this reason the authors use a
technique called data dependent baselines to achieve good performance.
This technique can be implemented in Pyro, and we’ll see how later in
the tutorial.</p>
</div>
<div class="section" id="The-Model">
<h2>The Model<a class="headerlink" href="#The-Model" title="Permalink to this headline">¶</a></h2>
<div class="section" id="Generating-a-single-object">
<h3>Generating a single object<a class="headerlink" href="#Generating-a-single-object" title="Permalink to this headline">¶</a></h3>
<p>Let’s look at the model more closely. At the core of the model is the
generative process for a single object. Recall that:</p>
<ul class="simple">
<li>At each step a single object is generated.</li>
<li>Each object is generated by passing its latent code through a neural
network.</li>
<li>We maintain uncertainty about the latent code used to generate each
object, as well as its pose.</li>
</ul>
<p>This can be expressed in Pyro like so:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="c1"># Create the neural network. This takes a latent code, z_what, to pixel intensities.</span>
<span class="k">class</span> <span class="nc">Decoder</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Decoder</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">l1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">l2</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">400</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z_what</span><span class="p">):</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">relu</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l1</span><span class="p">(</span><span class="n">z_what</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">sigmoid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l2</span><span class="p">(</span><span class="n">h</span><span class="p">))</span>

<span class="n">decode</span> <span class="o">=</span> <span class="n">Decoder</span><span class="p">()</span>

<span class="n">z_where_prior_mu</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
<span class="n">z_where_prior_sigma</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
<span class="n">z_what_prior_mu</span> <span class="o">=</span> <span class="n">ng_zeros</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>
<span class="n">z_what_prior_sigma</span> <span class="o">=</span> <span class="n">ng_ones</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">model_step_sketch</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="c1"># Sample object pose. This is a 3-dimensional vector representing x,y position and size.</span>
    <span class="n">z_where</span> <span class="o">=</span> <span class="n">pyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s1">&#39;z_where_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="p">),</span>
                          <span class="n">dist</span><span class="o">.</span><span class="n">normal</span><span class="p">,</span>
                          <span class="n">z_where_prior_mu</span><span class="p">,</span>
                          <span class="n">z_where_prior_sigma</span><span class="p">,</span>
                          <span class="n">batch_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Sample object code. This is a 50-dimensional vector.</span>
    <span class="n">z_what</span> <span class="o">=</span> <span class="n">pyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s1">&#39;z_what_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="p">),</span>
                         <span class="n">dist</span><span class="o">.</span><span class="n">normal</span><span class="p">,</span>
                         <span class="n">z_what_prior_mu</span><span class="p">,</span>
                         <span class="n">z_what_prior_sigma</span><span class="p">,</span>
                         <span class="n">batch_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Map code to pixel space using the neural network.</span>
    <span class="n">y_att</span> <span class="o">=</span> <span class="n">decode</span><span class="p">(</span><span class="n">z_what</span><span class="p">)</span>

    <span class="c1"># Position/scale object within larger image.</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">object_to_image</span><span class="p">(</span><span class="n">z_where</span><span class="p">,</span> <span class="n">y_att</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">y</span>
</pre></div>
</div>
</div>
<p>Hopefully the use of <code class="docutils literal"><span class="pre">pyro.sample</span></code> and PyTorch networks within a model
seem familiar at this point. If not you might want to review earlier
parts of the tutorial. One thing to note is that we include the current
step <code class="docutils literal"><span class="pre">t</span></code> in the name passed to <code class="docutils literal"><span class="pre">pyro.sample</span></code> to ensure that names
are unique across steps.</p>
<p>The <code class="docutils literal"><span class="pre">object_to_image</span></code> function is specific to this model and warrants
further attention. Recall that the neural network (<code class="docutils literal"><span class="pre">decode</span></code> here) will
output a small image, and that we would like to add this to the output
image after performing any translation and scaling required to achieve
the pose (location and size) described by <code class="docutils literal"><span class="pre">z_where</span></code>. It’s not clear
how to do this, and in particular it’s not obvious that this can be
implemented in a way that preserves the differentiability of our model.
However, it turns out we can do this this using a spatial transformer
network (STN) [2].</p>
<p>Happily for us, PyTorch makes it easy to implement a STN using its
<code class="docutils literal"><span class="pre">`grid_sample</span></code> &lt;<a class="reference external" href="http://pytorch.org/docs/master/nn.html#grid-sample">http://pytorch.org/docs/master/nn.html#grid-sample</a>&gt;`__
and
<code class="docutils literal"><span class="pre">`affine_grid</span></code> &lt;<a class="reference external" href="http://pytorch.org/docs/master/nn.html#affine-grid">http://pytorch.org/docs/master/nn.html#affine-grid</a>&gt;`__
functions. <code class="docutils literal"><span class="pre">object_to_image</span></code> is a simple function that calls these,
doing a little extra work to massage <code class="docutils literal"><span class="pre">z_where</span></code> into the expected
format.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="k">def</span> <span class="nf">expand_z_where</span><span class="p">(</span><span class="n">z_where</span><span class="p">):</span>
    <span class="c1"># Takes three vectors, and massages them into 2x3 matrices with elements like so:</span>
    <span class="c1"># [s,x,y] -&gt; [[s,0,x],</span>
    <span class="c1">#             [0,s,y]]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">z_where</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">expansion_indices</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">LongTensor</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">ng_zeros</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">z_where</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">index_select</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">expansion_indices</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">object_to_image</span><span class="p">(</span><span class="n">z_where</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">expand_z_where</span><span class="p">(</span><span class="n">z_where</span><span class="p">)</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">affine_grid</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">)))</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">grid_sample</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="n">grid</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>A discussion of the details of the STN is beyond the scope of this
tutorial. For our purposes however, it suffices to keep in mind that
<code class="docutils literal"><span class="pre">object_to_image</span></code> takes the small image generated by the neural
network and places it within a larger image with the desired pose.</p>
<p>Let’s visualize the results of calling <code class="docutils literal"><span class="pre">model_step_sketch</span></code> a few times
to clarify this:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="n">pyro</span><span class="o">.</span><span class="n">set_rng_seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">samples</span> <span class="o">=</span> <span class="p">[</span><span class="n">model_step_sketch</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="n">show_images</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
<span class="ansi-red-fg">---------------------------------------------------------------------------</span>
<span class="ansi-red-fg">NameError</span>                                 Traceback (most recent call last)
<span class="ansi-green-fg">&lt;ipython-input-5-76958b9a4703&gt;</span> in <span class="ansi-cyan-fg">&lt;module&gt;</span><span class="ansi-blue-fg">()</span>
<span class="ansi-green-intense-fg ansi-bold">      1</span> pyro<span class="ansi-blue-fg">.</span>set_rng_seed<span class="ansi-blue-fg">(</span><span class="ansi-cyan-fg">0</span><span class="ansi-blue-fg">)</span>
<span class="ansi-green-intense-fg ansi-bold">      2</span> samples <span class="ansi-blue-fg">=</span> <span class="ansi-blue-fg">[</span>model_step_sketch<span class="ansi-blue-fg">(</span><span class="ansi-cyan-fg">0</span><span class="ansi-blue-fg">)</span><span class="ansi-blue-fg">[</span><span class="ansi-cyan-fg">0</span><span class="ansi-blue-fg">]</span> <span class="ansi-green-fg">for</span> _ <span class="ansi-green-fg">in</span> range<span class="ansi-blue-fg">(</span><span class="ansi-cyan-fg">5</span><span class="ansi-blue-fg">)</span><span class="ansi-blue-fg">]</span>
<span class="ansi-green-fg">----&gt; 3</span><span class="ansi-red-fg"> </span>show_images<span class="ansi-blue-fg">(</span>samples<span class="ansi-blue-fg">)</span>

<span class="ansi-red-fg">NameError</span>: name &#39;show_images&#39; is not defined
</pre></div></div>
</div>
</div>
<div class="section" id="Generating-an-entire-image">
<h3>Generating an entire image<a class="headerlink" href="#Generating-an-entire-image" title="Permalink to this headline">¶</a></h3>
<p>Having completed the implementation of a single step, we next consider
how we can use this to generate an entire image. Recall that we would
like to maintain uncertainty over the number of steps used to generate
each data point. One choice we could make for the prior over the number
of steps is the geometric distribution, which can be expressed as
follows:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="n">pyro</span><span class="o">.</span><span class="n">set_rng_seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">geom</span><span class="p">(</span><span class="n">num_trials</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">([</span><span class="mf">0.5</span><span class="p">]))</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">pyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s1">&#39;x</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">num_trials</span><span class="p">),</span> <span class="n">dist</span><span class="o">.</span><span class="n">bernoulli</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">num_trials</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">geom</span><span class="p">(</span><span class="n">num_trials</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># Generate some samples.</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;sampled </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">geom</span><span class="p">()))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
sampled 8
sampled 2
sampled 0
sampled 0
sampled 1
</pre></div></div>
</div>
<p>This is a direct translation of the definition of the geometric
distribution as the number of failures before a success in a series of
Bernoulli trials. Here we express this as a recursive function that
passes around a counter representing the number of trials made,
<code class="docutils literal"><span class="pre">num_trials</span></code>. This function samples from the Bernoulli and returns
<code class="docutils literal"><span class="pre">num_trials</span></code> if <code class="docutils literal"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">1</span></code> (which represents success), otherwise it
makes a recursive call, incrementing the counter.</p>
<p>The use of a geometric prior is appealing because it does not bound the
number of steps the model can use a priori. It’s also convenient,
because by extending <code class="docutils literal"><span class="pre">geometric</span></code> to generate an object before each
recursive call, we turn this from a geometric distribution over counts
to a distribution over images with a geometrically distributed number of
steps.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="k">def</span> <span class="nf">geom_prior</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">([</span><span class="mf">0.5</span><span class="p">]))</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">pyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s1">&#39;i</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">step</span><span class="p">),</span> <span class="n">dist</span><span class="o">.</span><span class="n">bernoulli</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">model_step_sketch</span><span class="p">(</span><span class="n">step</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">geom_prior</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">step</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>Let’s visualize some samples from this distribution:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="n">pyro</span><span class="o">.</span><span class="n">set_rng_seed</span><span class="p">(</span><span class="mi">13</span><span class="p">)</span>
<span class="n">x_empty</span> <span class="o">=</span> <span class="n">ng_zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="n">samples</span> <span class="o">=</span> <span class="p">[</span><span class="n">geom_prior</span><span class="p">(</span><span class="n">x_empty</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="n">show_images</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
<span class="ansi-red-fg">---------------------------------------------------------------------------</span>
<span class="ansi-red-fg">NameError</span>                                 Traceback (most recent call last)
<span class="ansi-green-fg">&lt;ipython-input-8-b0875338af3b&gt;</span> in <span class="ansi-cyan-fg">&lt;module&gt;</span><span class="ansi-blue-fg">()</span>
<span class="ansi-green-intense-fg ansi-bold">      2</span> x_empty <span class="ansi-blue-fg">=</span> ng_zeros<span class="ansi-blue-fg">(</span><span class="ansi-cyan-fg">1</span><span class="ansi-blue-fg">,</span> <span class="ansi-cyan-fg">50</span><span class="ansi-blue-fg">,</span> <span class="ansi-cyan-fg">50</span><span class="ansi-blue-fg">)</span>
<span class="ansi-green-intense-fg ansi-bold">      3</span> samples <span class="ansi-blue-fg">=</span> <span class="ansi-blue-fg">[</span>geom_prior<span class="ansi-blue-fg">(</span>x_empty<span class="ansi-blue-fg">)</span><span class="ansi-blue-fg">[</span><span class="ansi-cyan-fg">0</span><span class="ansi-blue-fg">]</span> <span class="ansi-green-fg">for</span> _ <span class="ansi-green-fg">in</span> range<span class="ansi-blue-fg">(</span><span class="ansi-cyan-fg">5</span><span class="ansi-blue-fg">)</span><span class="ansi-blue-fg">]</span>
<span class="ansi-green-fg">----&gt; 4</span><span class="ansi-red-fg"> </span>show_images<span class="ansi-blue-fg">(</span>samples<span class="ansi-blue-fg">)</span>

<span class="ansi-red-fg">NameError</span>: name &#39;show_images&#39; is not defined
</pre></div></div>
</div>
<div class="section" id="Aside:-Vectorized-mini-batches">
<h4>Aside: Vectorized mini-batches<a class="headerlink" href="#Aside:-Vectorized-mini-batches" title="Permalink to this headline">¶</a></h4>
<p>In our final implementation we would like to generate a mini batch of
samples in parallel for efficiency. While Pyro supports vectorized mini
batches with <code class="docutils literal"><span class="pre">iarange</span></code>, it currently assumes that each <code class="docutils literal"><span class="pre">sample</span></code>
statement within <code class="docutils literal"><span class="pre">iarange</span></code> makes a choice for all samples in the mini
batch. This is problematic for us because as we have just seen, each
sample from our model can take a different number of steps, and hence
make a different number of choices.</p>
<p>One way around this is to arrange for all samples to take the same
number of steps. Of course, we still want to have differing numbers of
objects in the images we generate, so we will take the occurance of a
successful Bernoulli trial to indicate that we should stop adding the
objects we generate to the output image, and use some other criteria to
decide when to stop making further steps.</p>
<p>Even though this approach performs redundant computation, the gains from
using mini batches are so large that this is still a win overall.
(Eventually though, we’d like to be able to express the model in a way
that avoids this redundant computation.)</p>
<p>Following [1] we choose to take a fixed number of steps for each sample.
(By doing so we no longer specify a geometric distribution over the
number of steps, since the number of steps is now bounded. It would be
interesting to explore the alternative of having each sample in the
batch take steps until a successful Bernoulli trial has occured in each,
as this would retain the geometric prior.)</p>
<p>Here’s an updated model step function that implements this idea. The
only changes from <code class="docutils literal"><span class="pre">model_step_sketch</span></code> are that we now conditionally
add the object to the output image based on the outcome for a new
Bernoulli random draw, and we’ve added a new parameter <code class="docutils literal"><span class="pre">n</span></code> that
specifies the size of the mini batch.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="k">def</span> <span class="nf">model_step</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">prev_x</span><span class="p">,</span> <span class="n">prev_z_pres</span><span class="p">):</span>

    <span class="c1"># Sample variable indicating whether to add this object to the output.</span>

    <span class="c1"># We multiple the success probability of 0.5 by the value sampled for this</span>
    <span class="c1"># choice in the previous step. By doing so we add objects to the output until</span>
    <span class="c1"># the first 0 is sampled, after which we add no further objects.</span>
    <span class="n">z_pres</span> <span class="o">=</span> <span class="n">pyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s1">&#39;z_pres_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">dist</span><span class="o">.</span><span class="n">bernoulli</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">prev_z_pres</span><span class="p">)</span>

    <span class="n">z_where</span> <span class="o">=</span> <span class="n">pyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s1">&#39;z_where_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="p">),</span>
                          <span class="n">dist</span><span class="o">.</span><span class="n">normal</span><span class="p">,</span>
                          <span class="n">z_where_prior_mu</span><span class="p">,</span>
                          <span class="n">z_where_prior_sigma</span><span class="p">,</span>
                          <span class="n">batch_size</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>

    <span class="n">z_what</span> <span class="o">=</span> <span class="n">pyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s1">&#39;z_what_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="p">),</span>
                         <span class="n">dist</span><span class="o">.</span><span class="n">normal</span><span class="p">,</span>
                         <span class="n">z_what_prior_mu</span><span class="p">,</span>
                         <span class="n">z_what_prior_sigma</span><span class="p">,</span>
                         <span class="n">batch_size</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>

    <span class="n">y_att</span> <span class="o">=</span> <span class="n">decode</span><span class="p">(</span><span class="n">z_what</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">object_to_image</span><span class="p">(</span><span class="n">z_where</span><span class="p">,</span> <span class="n">y_att</span><span class="p">)</span>

    <span class="c1"># Combine the image generated at this step with the image so far.</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">prev_x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">z_pres</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">z_pres</span>
</pre></div>
</div>
</div>
<p>By iterating this step function we can produce an entire image, composed
of multiple objects. Since each image in the multi-mnist dataset
contains zero, one or two digits we will allow the model to use up to
(and including) three steps. This will allow us to observe whether
inference avoids using the unnecessary final step, and to test the
model’s ability to generalize to images with more digits than are
present in the dataset.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="k">def</span> <span class="nf">prior</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">ng_zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
    <span class="n">z_pres</span> <span class="o">=</span> <span class="n">ng_ones</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">z_pres</span> <span class="o">=</span> <span class="n">model_step</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z_pres</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span>
</pre></div>
</div>
</div>
<p>We have now fully specified the prior for our model. Let’s visualize
some samples to get a feel for this distribution:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [11]:
</pre></div>
</div>
<div class="input_area highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="n">pyro</span><span class="o">.</span><span class="n">set_rng_seed</span><span class="p">(</span><span class="mi">87678</span><span class="p">)</span>
<span class="n">show_images</span><span class="p">(</span><span class="n">prior</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
<span class="ansi-red-fg">---------------------------------------------------------------------------</span>
<span class="ansi-red-fg">NameError</span>                                 Traceback (most recent call last)
<span class="ansi-green-fg">&lt;ipython-input-11-ecaf4d598920&gt;</span> in <span class="ansi-cyan-fg">&lt;module&gt;</span><span class="ansi-blue-fg">()</span>
<span class="ansi-green-intense-fg ansi-bold">      1</span> pyro<span class="ansi-blue-fg">.</span>set_rng_seed<span class="ansi-blue-fg">(</span><span class="ansi-cyan-fg">87678</span><span class="ansi-blue-fg">)</span>
<span class="ansi-green-fg">----&gt; 2</span><span class="ansi-red-fg"> </span>show_images<span class="ansi-blue-fg">(</span>prior<span class="ansi-blue-fg">(</span><span class="ansi-cyan-fg">5</span><span class="ansi-blue-fg">)</span><span class="ansi-blue-fg">)</span>

<span class="ansi-red-fg">NameError</span>: name &#39;show_images&#39; is not defined
</pre></div></div>
</div>
</div>
<div class="section" id="Specifying-the-likelihood">
<h4>Specifying the likelihood<a class="headerlink" href="#Specifying-the-likelihood" title="Permalink to this headline">¶</a></h4>
<p>The last thing we need in order to complete the specification of the
model is a likelihood function. Following [1] we will use a Gaussian
likelihood with a fixed standard deviation of 0.3. This is straight
forward to implement using <code class="docutils literal"><span class="pre">pyro.observe</span></code>.</p>
<p>When we later come to perform inference we will find it convenient to
package the prior and likelihood into a single function. This is also a
convenient place to introduce <code class="docutils literal"><span class="pre">iarange</span></code>, which we use to implement
data subsampling, and to register the networks we would like to optimize
with <code class="docutils literal"><span class="pre">pyro.module</span></code>. (LINK: iarange, module docs)</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [12]:
</pre></div>
</div>
<div class="input_area highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="k">def</span> <span class="nf">model</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="c1"># Register network for optimization.</span>
    <span class="n">pyro</span><span class="o">.</span><span class="n">module</span><span class="p">(</span><span class="s2">&quot;decode&quot;</span><span class="p">,</span> <span class="n">decode</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">pyro</span><span class="o">.</span><span class="n">iarange</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="k">as</span> <span class="n">indices</span><span class="p">:</span>
        <span class="n">batch</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">prior</span><span class="p">(</span><span class="n">batch</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">50</span> <span class="o">*</span> <span class="mi">50</span><span class="p">)</span>
        <span class="n">sd</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.3</span> <span class="o">*</span> <span class="n">ng_ones</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">expand_as</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">pyro</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="s1">&#39;obs&#39;</span><span class="p">,</span> <span class="n">dist</span><span class="o">.</span><span class="n">normal</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">sd</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="The-Guide">
<h2>The Guide<a class="headerlink" href="#The-Guide" title="Permalink to this headline">¶</a></h2>
<p>Following [1] we will perform <a class="reference external" href="http://pyro.ai/examples/svi_part_i.html">amortized variational
inference</a> in this model.
Pyro provides general purpose machinery that implements most of this
inference strategy, but as we have seen in earlier tutorials we are
required to provide a model specific guide. What we call a guide in Pyro
is exactly the entity called the “inference network” in the paper.</p>
<p>We will structure the guide around a recurrent network to allow the
guide to capture (some of) the dependencies we expect to be present in
the true posterior. At each step the recurrent network will generate the
parameters for the choices made within the step. The values sampled will
be fed back into the recurrent network so that this information can be
used when computing the parameters for the next step. The guide for the
<a class="reference external" href="http://pyro.ai/examples/dmm/dmm_tutorial.html">Deep Markov Model</a>
shares a similar structure.</p>
<p>As in the model, the core of the guide is the logic for a single step.
Here’s a sketch of an implementation of this:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [13]:
</pre></div>
</div>
<div class="input_area highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="k">def</span> <span class="nf">guide_step_basic</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">prev</span><span class="p">):</span>

    <span class="c1"># The RNN takes the images and choices from the previous step as input.</span>
    <span class="n">rnn_input</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">data</span><span class="p">,</span> <span class="n">prev</span><span class="o">.</span><span class="n">z_where</span><span class="p">,</span> <span class="n">prev</span><span class="o">.</span><span class="n">z_what</span><span class="p">,</span> <span class="n">prev</span><span class="o">.</span><span class="n">z_pres</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">h</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">rnn</span><span class="p">(</span><span class="n">rnn_input</span><span class="p">,</span> <span class="p">(</span><span class="n">prev</span><span class="o">.</span><span class="n">h</span><span class="p">,</span> <span class="n">prev</span><span class="o">.</span><span class="n">c</span><span class="p">))</span>

    <span class="c1"># Compute parameters for all choices made this step, by passing</span>
    <span class="c1"># the RNN hidden start through another neural network.</span>
    <span class="n">z_pres_p</span><span class="p">,</span> <span class="n">z_where_mu</span><span class="p">,</span> <span class="n">z_where_sigma</span><span class="p">,</span> <span class="n">z_what_mu</span><span class="p">,</span> <span class="n">z_what_sigma</span> <span class="o">=</span> <span class="n">predict_basic</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>

    <span class="n">z_pres</span> <span class="o">=</span> <span class="n">pyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s1">&#39;z_pres_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="p">),</span>
                         <span class="n">dist</span><span class="o">.</span><span class="n">bernoulli</span><span class="p">,</span> <span class="n">z_pres_p</span> <span class="o">*</span> <span class="n">prev</span><span class="o">.</span><span class="n">z_pres</span><span class="p">)</span>

    <span class="n">z_where</span> <span class="o">=</span> <span class="n">pyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s1">&#39;z_where_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="p">),</span>
                          <span class="n">dist</span><span class="o">.</span><span class="n">normal</span><span class="p">,</span> <span class="n">z_where_mu</span><span class="p">,</span> <span class="n">z_where_sigma</span><span class="p">)</span>

    <span class="n">z_what</span> <span class="o">=</span> <span class="n">pyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s1">&#39;z_what_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="p">),</span>
                         <span class="n">dist</span><span class="o">.</span><span class="n">normal</span><span class="p">,</span> <span class="n">z_what_mu</span><span class="p">,</span> <span class="n">z_what_sigma</span><span class="p">)</span>

    <span class="k">return</span> <span class="c1"># values for next step</span>
</pre></div>
</div>
</div>
<p>This would be a reasonable guide to use with this model, but the paper
describes a crucial improvement we can make to the code above. Recall
that the guide will output information about an object’s pose and its
latent code at each step. The improvement we can make is based on the
observation that once we have infered the pose of an object, we can do a
better job of infering its latent code if we use the pose information to
crop the object from the input image, and pass the result (which we’ll
call a “window”) through an additional network in order to compute the
parameters of the latent code. We’ll call this additional network the
“encoder” below.</p>
<p>Here’s how we can implement this improved guide, and a fleshed out
implementation of the networks involved:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [14]:
</pre></div>
</div>
<div class="input_area highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="n">rnn</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">LSTMCell</span><span class="p">(</span><span class="mi">2554</span><span class="p">,</span> <span class="mi">256</span><span class="p">)</span>

<span class="c1"># Takes pixel intensities of the attention window to parameters (mean,</span>
<span class="c1"># standard deviation) of the distribution over the latent code,</span>
<span class="c1"># z_what.</span>
<span class="k">class</span> <span class="nc">Encoder</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Encoder</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">l1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">400</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">l2</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">relu</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l1</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">l2</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">50</span><span class="p">],</span> <span class="n">softplus</span><span class="p">(</span><span class="n">a</span><span class="p">[:,</span> <span class="mi">50</span><span class="p">:])</span>

<span class="n">encode</span> <span class="o">=</span> <span class="n">Encoder</span><span class="p">()</span>

<span class="c1"># Takes the guide RNN hidden state to parameters of</span>
<span class="c1"># the guide distributions over z_where and z_pres.</span>
<span class="k">class</span> <span class="nc">Predict</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Predict</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">l</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
        <span class="n">z_pres_p</span> <span class="o">=</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">a</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># Squish to [0,1]</span>
        <span class="n">z_where_mu</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">z_where_sigma</span> <span class="o">=</span> <span class="n">softplus</span><span class="p">(</span><span class="n">a</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">:])</span> <span class="c1"># Squish to &gt;0</span>
        <span class="k">return</span> <span class="n">z_pres_p</span><span class="p">,</span> <span class="n">z_where_mu</span><span class="p">,</span> <span class="n">z_where_sigma</span>

<span class="n">predict</span> <span class="o">=</span> <span class="n">Predict</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">guide_step_improved</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">prev</span><span class="p">):</span>

    <span class="n">rnn_input</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">data</span><span class="p">,</span> <span class="n">prev</span><span class="o">.</span><span class="n">z_where</span><span class="p">,</span> <span class="n">prev</span><span class="o">.</span><span class="n">z_what</span><span class="p">,</span> <span class="n">prev</span><span class="o">.</span><span class="n">z_pres</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">h</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">rnn</span><span class="p">(</span><span class="n">rnn_input</span><span class="p">,</span> <span class="p">(</span><span class="n">prev</span><span class="o">.</span><span class="n">h</span><span class="p">,</span> <span class="n">prev</span><span class="o">.</span><span class="n">c</span><span class="p">))</span>
    <span class="n">z_pres_p</span><span class="p">,</span> <span class="n">z_where_mu</span><span class="p">,</span> <span class="n">z_where_sigma</span> <span class="o">=</span> <span class="n">predict</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>

    <span class="n">z_pres</span> <span class="o">=</span> <span class="n">pyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s1">&#39;z_pres_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="p">),</span>
                         <span class="n">dist</span><span class="o">.</span><span class="n">bernoulli</span><span class="p">,</span> <span class="n">z_pres_p</span> <span class="o">*</span> <span class="n">prev</span><span class="o">.</span><span class="n">z_pres</span><span class="p">)</span>

    <span class="n">z_where</span> <span class="o">=</span> <span class="n">pyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s1">&#39;z_where_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="p">),</span>
                          <span class="n">dist</span><span class="o">.</span><span class="n">normal</span><span class="p">,</span> <span class="n">z_where_mu</span><span class="p">,</span> <span class="n">z_where_sigma</span><span class="p">)</span>

    <span class="c1"># New. Crop a small window from the input.</span>
    <span class="n">x_att</span> <span class="o">=</span> <span class="n">image_to_object</span><span class="p">(</span><span class="n">z_where</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="c1"># Compute the parameter of the distribution over z_what</span>
    <span class="c1"># by passing the window through the encoder network.</span>
    <span class="n">z_what_mu</span><span class="p">,</span> <span class="n">z_what_sigma</span> <span class="o">=</span> <span class="n">encode</span><span class="p">(</span><span class="n">x_att</span><span class="p">)</span>

    <span class="n">z_what</span> <span class="o">=</span> <span class="n">pyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s1">&#39;z_what_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="p">),</span>
                         <span class="n">dist</span><span class="o">.</span><span class="n">normal</span><span class="p">,</span> <span class="n">z_what_mu</span><span class="p">,</span> <span class="n">z_what_sigma</span><span class="p">)</span>

    <span class="k">return</span> <span class="c1"># values for next step</span>
</pre></div>
</div>
</div>
<p>Since we would like to maintain differentiability of the guide we again
use a STN to perform the required “cropping”. The <code class="docutils literal"><span class="pre">image_to_object</span></code>
function performs the opposite transform to the object_to_image function
used in the guide. That is, the former takes a small image and places it
on a larger image, and the latter crops a small image from a larger
image.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [15]:
</pre></div>
</div>
<div class="input_area highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="k">def</span> <span class="nf">z_where_inv</span><span class="p">(</span><span class="n">z_where</span><span class="p">):</span>
    <span class="c1"># Take a batch of z_where vectors, and compute their &quot;inverse&quot;.</span>
    <span class="c1"># That is, for each row compute:</span>
    <span class="c1"># [s,x,y] -&gt; [1/s,-x/s,-y/s]</span>
    <span class="c1"># These are the parameters required to perform the inverse of the</span>
    <span class="c1"># spatial transform performed in the generative model.</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">z_where</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">ng_ones</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">type_as</span><span class="p">(</span><span class="n">z_where</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="o">-</span><span class="n">z_where</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">out</span> <span class="o">/</span> <span class="n">z_where</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">out</span>

<span class="k">def</span> <span class="nf">image_to_object</span><span class="p">(</span><span class="n">z_where</span><span class="p">,</span> <span class="n">image</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">theta_inv</span> <span class="o">=</span> <span class="n">expand_z_where</span><span class="p">(</span><span class="n">z_where_inv</span><span class="p">(</span><span class="n">z_where</span><span class="p">))</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">affine_grid</span><span class="p">(</span><span class="n">theta_inv</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">)))</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">grid_sample</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="n">grid</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="Another-perspective">
<h3>Another perspective<a class="headerlink" href="#Another-perspective" title="Permalink to this headline">¶</a></h3>
<p>So far we’ve considered the model and the guide in isolation, but we
gain an interesting perspective if we zoom out and look at the model and
guide computation as a whole. Doing so, we see that at each step AIR
includes a sub-computation that has the same structure as a <a class="reference external" href="http://pyro.ai/examples/svi_part_i.html">Variational
Auto-encoder</a> (VAE).</p>
<p>To see this, notice that the guide passes the window through a neural
network (the encoder) to generate the parameters of the distribution
over a latent code, and the model passes samples from this latent code
distribution through another neural network (the decoder) to generate an
output window. This structure is highlighted in the following figure,
reproduced from [1]:</p>
<p>From this perspective AIR is seen as a sequential variant of the VAE.
The act of cropping a small window from the input image serves to
restrict the attention of a VAE to a small region of the input image at
each step; hence “Attend, Infer, Repeat”.</p>
</div>
</div>
<div class="section" id="Inference">
<h2>Inference<a class="headerlink" href="#Inference" title="Permalink to this headline">¶</a></h2>
<p>As we mentioned in the introduction, successfully performing inference
in this model is a challenge. In particular, the presence of discrete
choices in the model makes inference trickier than in a model in which
all choices can be reparameterized. The underlying problem we face is
that the gradient estimates we use in the optimization performed by
variational inference have much higher variance in the presence of
discrete choices.</p>
<p>To bring this variance under control, the paper applies a technique
called “data dependent baselines” (AKA “neural baselines”) to the
discrete choices in the model.</p>
<div class="section" id="Data-dependent-baselines">
<h3>Data dependent baselines<a class="headerlink" href="#Data-dependent-baselines" title="Permalink to this headline">¶</a></h3>
<p>Happily for us, Pyro includes support for data dependent baselines. If
you are not already familiar with this idea, you might want to read <a class="reference external" href="http://pyro.ai/examples/svi_part_iii.html">our
introduction</a> before
continuing. As model authors we only have to implement the neural
network, pass it our data as input, and feed its output to
<code class="docutils literal"><span class="pre">pyro.sample</span></code>. Pyro’s inference back-end will ensure that the baseline
is included in the gradient estimator used for inference, and that the
network parameters are updated appropriately.</p>
<p>Let’s see how we can add data dependent baselines to our AIR
implementation. We need a neural network that can output a (scalar)
baseline value at each discrete choice in the guide, having received a
multi-mnist image and the values sampled by the guide so far as input.
Notice that this is very similar to the structure of the guide network,
and indeed we will again use a recurrent network.</p>
<p>To implement this we will first write a short helper function that
implements a single step of the RNN we’ve just described:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [16]:
</pre></div>
</div>
<div class="input_area highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="n">bl_rnn</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">LSTMCell</span><span class="p">(</span><span class="mi">2554</span><span class="p">,</span> <span class="mi">256</span><span class="p">)</span>
<span class="n">bl_predict</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># Use an RNN to compute the baseline value. This network takes the</span>
<span class="c1"># input images and the values samples so far as input.</span>
<span class="k">def</span> <span class="nf">baseline_step</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">prev</span><span class="p">):</span>
    <span class="n">rnn_input</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">x</span><span class="p">,</span>
                           <span class="n">prev</span><span class="o">.</span><span class="n">z_where</span><span class="o">.</span><span class="n">detach</span><span class="p">(),</span>
                           <span class="n">prev</span><span class="o">.</span><span class="n">z_what</span><span class="o">.</span><span class="n">detach</span><span class="p">(),</span>
                           <span class="n">prev</span><span class="o">.</span><span class="n">z_pres</span><span class="o">.</span><span class="n">detach</span><span class="p">()),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">bl_h</span><span class="p">,</span> <span class="n">bl_c</span> <span class="o">=</span> <span class="n">bl_rnn</span><span class="p">(</span><span class="n">rnn_input</span><span class="p">,</span> <span class="p">(</span><span class="n">prev</span><span class="o">.</span><span class="n">bl_h</span><span class="p">,</span> <span class="n">prev</span><span class="o">.</span><span class="n">bl_c</span><span class="p">))</span>
    <span class="n">bl_value</span> <span class="o">=</span> <span class="n">bl_predict</span><span class="p">(</span><span class="n">bl_h</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">bl_value</span><span class="p">,</span> <span class="n">bl_h</span><span class="p">,</span> <span class="n">bl_c</span>
</pre></div>
</div>
</div>
<p>Notice that we <code class="docutils literal"><span class="pre">detach</span></code> values sampled by the guide before passing
them to the baseline network. This is important as the baseline network
and the guide network are entirely separate networks optimized with
different objectives. Without this, gradients would flow from the
baseline network in to the guide network. When using data dependent
baselines we must do this whenever we feed values sampled by the guide
into the baselines network. (If we don’t we’ll trigger a PyTorch
run-time error.)</p>
<p>We now have everything we need to complete the implementation of the
guide. Our final <code class="docutils literal"><span class="pre">guide_step</span></code> function will be very similar to
<code class="docutils literal"><span class="pre">guide_step_improved</span></code> introduced above. The only change is that we
will call the <code class="docutils literal"><span class="pre">baseline_step</span></code> helper and pass the baseline value it
returns to <code class="docutils literal"><span class="pre">pyro.sample</span></code>, completing the baseline implementation.
We’ll also write a <code class="docutils literal"><span class="pre">guide</span></code> function that will iterate <code class="docutils literal"><span class="pre">guide_step</span></code>
in order to provide a guide for the whole model.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [17]:
</pre></div>
</div>
<div class="input_area highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="n">GuideState</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;GuideState&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;bl_h&#39;</span><span class="p">,</span> <span class="s1">&#39;bl_c&#39;</span><span class="p">,</span> <span class="s1">&#39;z_pres&#39;</span><span class="p">,</span> <span class="s1">&#39;z_where&#39;</span><span class="p">,</span> <span class="s1">&#39;z_what&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">initial_guide_state</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">GuideState</span><span class="p">(</span><span class="n">h</span><span class="o">=</span><span class="n">ng_zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">256</span><span class="p">),</span>
                      <span class="n">c</span><span class="o">=</span><span class="n">ng_zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">256</span><span class="p">),</span>
                      <span class="n">bl_h</span><span class="o">=</span><span class="n">ng_zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">256</span><span class="p">),</span>
                      <span class="n">bl_c</span><span class="o">=</span><span class="n">ng_zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">256</span><span class="p">),</span>
                      <span class="n">z_pres</span><span class="o">=</span><span class="n">ng_ones</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                      <span class="n">z_where</span><span class="o">=</span><span class="n">ng_zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                      <span class="n">z_what</span><span class="o">=</span><span class="n">ng_zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">guide_step</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">prev</span><span class="p">):</span>

    <span class="n">rnn_input</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">data</span><span class="p">,</span> <span class="n">prev</span><span class="o">.</span><span class="n">z_where</span><span class="p">,</span> <span class="n">prev</span><span class="o">.</span><span class="n">z_what</span><span class="p">,</span> <span class="n">prev</span><span class="o">.</span><span class="n">z_pres</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">h</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">rnn</span><span class="p">(</span><span class="n">rnn_input</span><span class="p">,</span> <span class="p">(</span><span class="n">prev</span><span class="o">.</span><span class="n">h</span><span class="p">,</span> <span class="n">prev</span><span class="o">.</span><span class="n">c</span><span class="p">))</span>
    <span class="n">z_pres_p</span><span class="p">,</span> <span class="n">z_where_mu</span><span class="p">,</span> <span class="n">z_where_sigma</span> <span class="o">=</span> <span class="n">predict</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>

    <span class="c1"># Here we compute the baseline value, and pass it to sample.</span>
    <span class="n">baseline_value</span><span class="p">,</span> <span class="n">bl_h</span><span class="p">,</span> <span class="n">bl_c</span> <span class="o">=</span> <span class="n">baseline_step</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">prev</span><span class="p">)</span>
    <span class="n">z_pres</span> <span class="o">=</span> <span class="n">pyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s1">&#39;z_pres_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="p">),</span>
                         <span class="n">dist</span><span class="o">.</span><span class="n">bernoulli</span><span class="p">,</span>
                         <span class="n">z_pres_p</span> <span class="o">*</span> <span class="n">prev</span><span class="o">.</span><span class="n">z_pres</span><span class="p">,</span>
                         <span class="n">baseline</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">baseline_value</span><span class="o">=</span><span class="n">baseline_value</span><span class="p">))</span>

    <span class="n">z_where</span> <span class="o">=</span> <span class="n">pyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s1">&#39;z_where_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="p">),</span>
                          <span class="n">dist</span><span class="o">.</span><span class="n">normal</span><span class="p">,</span> <span class="n">z_where_mu</span><span class="p">,</span> <span class="n">z_where_sigma</span><span class="p">)</span>

    <span class="n">x_att</span> <span class="o">=</span> <span class="n">image_to_object</span><span class="p">(</span><span class="n">z_where</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="n">z_what_mu</span><span class="p">,</span> <span class="n">z_what_sigma</span> <span class="o">=</span> <span class="n">encode</span><span class="p">(</span><span class="n">x_att</span><span class="p">)</span>

    <span class="n">z_what</span> <span class="o">=</span> <span class="n">pyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s1">&#39;z_what_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="p">),</span>
                         <span class="n">dist</span><span class="o">.</span><span class="n">normal</span><span class="p">,</span> <span class="n">z_what_mu</span><span class="p">,</span> <span class="n">z_what_sigma</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">GuideState</span><span class="p">(</span><span class="n">h</span><span class="o">=</span><span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">bl_h</span><span class="o">=</span><span class="n">bl_h</span><span class="p">,</span> <span class="n">bl_c</span><span class="o">=</span><span class="n">bl_c</span><span class="p">,</span> <span class="n">z_pres</span><span class="o">=</span><span class="n">z_pres</span><span class="p">,</span> <span class="n">z_where</span><span class="o">=</span><span class="n">z_where</span><span class="p">,</span> <span class="n">z_what</span><span class="o">=</span><span class="n">z_what</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">guide</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="c1"># Register networks for optimization.</span>
    <span class="n">pyro</span><span class="o">.</span><span class="n">module</span><span class="p">(</span><span class="s1">&#39;rnn&#39;</span><span class="p">,</span> <span class="n">rnn</span><span class="p">),</span>
    <span class="n">pyro</span><span class="o">.</span><span class="n">module</span><span class="p">(</span><span class="s1">&#39;predict&#39;</span><span class="p">,</span> <span class="n">predict</span><span class="p">),</span>
    <span class="n">pyro</span><span class="o">.</span><span class="n">module</span><span class="p">(</span><span class="s1">&#39;encode&#39;</span><span class="p">,</span> <span class="n">encode</span><span class="p">),</span>
    <span class="n">pyro</span><span class="o">.</span><span class="n">module</span><span class="p">(</span><span class="s1">&#39;bl_rnn&#39;</span><span class="p">,</span> <span class="n">bl_rnn</span><span class="p">)</span>
    <span class="n">pyro</span><span class="o">.</span><span class="n">module</span><span class="p">(</span><span class="s1">&#39;bl_predict&#39;</span><span class="p">,</span> <span class="n">bl_predict</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">pyro</span><span class="o">.</span><span class="n">iarange</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">subsample_size</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span> <span class="k">as</span> <span class="n">indices</span><span class="p">:</span>
        <span class="n">batch</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">initial_guide_state</span><span class="p">(</span><span class="n">batch</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">steps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">guide_step</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="n">steps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">steps</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="Putting-it-altogether">
<h3>Putting it altogether<a class="headerlink" href="#Putting-it-altogether" title="Permalink to this headline">¶</a></h3>
<p>We have now completed the implementation of the model and the guide. As
we have already seen in earlier tutorials, we need write only a few more
lines of code to begin performing inference:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [18]:
</pre></div>
</div>
<div class="input_area highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="n">data</span> <span class="o">=</span> <span class="n">mnist</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">50</span> <span class="o">*</span> <span class="mi">50</span><span class="p">)</span>

<span class="n">svi</span> <span class="o">=</span> <span class="n">SVI</span><span class="p">(</span><span class="n">model</span><span class="p">,</span>
          <span class="n">guide</span><span class="p">,</span>
          <span class="n">optim</span><span class="o">.</span><span class="n">Adam</span><span class="p">({</span><span class="s1">&#39;lr&#39;</span><span class="p">:</span> <span class="mf">1e-4</span><span class="p">}),</span>
          <span class="n">loss</span><span class="o">=</span><span class="s1">&#39;ELBO&#39;</span><span class="p">,</span>
          <span class="n">trace_graph</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="n">svi</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;i=</span><span class="si">{}</span><span class="s1">, elbo=</span><span class="si">{:.2f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">loss</span> <span class="o">/</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
<span class="ansi-red-fg">---------------------------------------------------------------------------</span>
<span class="ansi-red-fg">NameError</span>                                 Traceback (most recent call last)
<span class="ansi-green-fg">&lt;ipython-input-18-e65499f789a9&gt;</span> in <span class="ansi-cyan-fg">&lt;module&gt;</span><span class="ansi-blue-fg">()</span>
<span class="ansi-green-fg">----&gt; 1</span><span class="ansi-red-fg"> </span>data <span class="ansi-blue-fg">=</span> mnist<span class="ansi-blue-fg">.</span>view<span class="ansi-blue-fg">(</span><span class="ansi-blue-fg">-</span><span class="ansi-cyan-fg">1</span><span class="ansi-blue-fg">,</span> <span class="ansi-cyan-fg">50</span> <span class="ansi-blue-fg">*</span> <span class="ansi-cyan-fg">50</span><span class="ansi-blue-fg">)</span>
<span class="ansi-green-intense-fg ansi-bold">      2</span>
<span class="ansi-green-intense-fg ansi-bold">      3</span> svi = SVI(model,
<span class="ansi-green-intense-fg ansi-bold">      4</span>           guide<span class="ansi-blue-fg">,</span>
<span class="ansi-green-intense-fg ansi-bold">      5</span>           optim<span class="ansi-blue-fg">.</span>Adam<span class="ansi-blue-fg">(</span><span class="ansi-blue-fg">{</span><span class="ansi-blue-fg">&#39;lr&#39;</span><span class="ansi-blue-fg">:</span> <span class="ansi-cyan-fg">1e-4</span><span class="ansi-blue-fg">}</span><span class="ansi-blue-fg">)</span><span class="ansi-blue-fg">,</span>

<span class="ansi-red-fg">NameError</span>: name &#39;mnist&#39; is not defined
</pre></div></div>
</div>
<p>One key detail here is that we pass the <code class="docutils literal"><span class="pre">trace_graph=True</span></code> option to
<code class="docutils literal"><span class="pre">SVI</span></code>. This enables a more <a class="reference external" href="http://pyro.ai/examples/svi_part_iii.html">sophisticated gradient
estimator</a> (implicity used
in [1]) that further reduces the variance of gradient estimates by
making use of independence information included in the model. Use of
this feature is necessary in order to achieve good results in the
presence of discrete choices.</p>
</div>
</div>
<div class="section" id="Improvements">
<h2>Improvements<a class="headerlink" href="#Improvements" title="Permalink to this headline">¶</a></h2>
<p>Here are a few ways in which the implementation given here might be
improved:</p>
<ul class="simple">
<li>It is reported to be useful in practice to use a different learning
rate for the baseline network. In [1] a learning rate of <code class="docutils literal"><span class="pre">1e-4</span></code> was
used for the guide network, and a learning rate of <code class="docutils literal"><span class="pre">1e-3</span></code> was used
for the baseline network. This is straight forward to implement in
Pyro by tagging modules (LINK: modules tagging docs) associated with
the baseline network and passing multiple learning rates to the
optimizer.</li>
<li>Use bigger neural networks.</li>
<li>Use optimizable parameters for the initial guide state.</li>
</ul>
</div>
<div class="section" id="Results">
<h2>Results<a class="headerlink" href="#Results" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal"><span class="pre">TODO:</span> <span class="pre">Add</span> <span class="pre">results</span></code></p>
</div>
<div class="section" id="References">
<h2>References<a class="headerlink" href="#References" title="Permalink to this headline">¶</a></h2>
<p>[1]
<code class="docutils literal"><span class="pre">Attend,</span> <span class="pre">Infer,</span> <span class="pre">Repeat:</span> <span class="pre">Fast</span> <span class="pre">Scene</span> <span class="pre">Understanding</span> <span class="pre">with</span> <span class="pre">Generative</span> <span class="pre">Models</span></code>
&nbsp;&nbsp;&nbsp;&nbsp; S. M. Ali Eslami and Nicolas Heess and Theophane Weber and Yuval
Tassa and Koray Kavukcuoglu and Geoffrey E. Hinton</p>
<p>[2] <code class="docutils literal"><span class="pre">Spatial</span> <span class="pre">Transformer</span> <span class="pre">Networks</span></code> &nbsp;&nbsp;&nbsp;&nbsp; Max Jaderberg and Karen
Simonyan and Andrew Zisserman</p>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="dmm.html" class="btn btn-neutral" title="Modeling Polyphonic Music with a Deep Markov Model" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Uber AI Labs.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>